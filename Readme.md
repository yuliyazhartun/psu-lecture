exercise1 - DRY - избавляемся от дублирирования кода путем деструктуризации значений 
***
exercise2 - KISS - принцип, согласно которому, нужно упрощать написание кода
***
exercise2 - YAGNI - по бизнес требованиям функция должна только считать два числа. Не нужно продумывать кейсы, когда функция должна умножать или делить их, пока это не станет необходимым. 

***

### Какой принцип реализован? Инкапсуляция 

#### Инкапсуляция — свойство системы, позволяющее объединить свойства и методы, работающие с ними, в классе или объекте с одновременным сокрытием внутренней структуры данных и реализации методов объекта от внешних обращений.

```javascript
function createGenerator(prefix) {
    let index = 0;
  return function genNewID() {
    index++; // значение переменной, объявленной во внешней функции, меняется, но вне функции genNewID() оно недоступно (изменить его нельзя)
    return prefix + index.toString();

  };
}
const generateNewID = createGenerator("вызов номер: ");
console.log(generateNewID()); // вызов номер: 1
console.log(generateNewID()); // вызов номер: 2
console.log(generateNewID()); // вызов номер: 3

console.log(index); // ReferenceError: index is not defined
```
***

### Какой принцип реализован? Наследование

#### Наследование — это принцип ооп, согласно которому одни классы, называемые родительскими, могут лежать в основе других — дочерних. При этом, дочерние классы перенимают свойства и поведение своего родителя.

```javascript
// Родительский класс (конструктор)
function Animal(name) {
    this.name = name;
  }
  
  // Методы родительского класса
  Animal.prototype.sayHello = function() {
    console.log('Привет, меня зовут ' + this.name);
  };
  
  // Дочерний класс (конструктор)
  function Cat(name, color) {
    // Вызов конструктора родительского класса
    Animal.call(this, name);
    
    // Дополнительные свойства дочернего класса
    this.color = color;
  }
  
  // Наследование прототипа
  Cat.prototype = Object.create(Animal.prototype);
  Cat.prototype.constructor = Cat;
  
  // Дополнительные методы дочернего класса
  Cat.prototype.meow = function() {
    console.log('Мяу, мяу!');
  };
  
  // Создание экземпляров классов
  var myAnimal = new Animal('Животное');
  var myCat = new Cat('Мурзик', 'рыжий');
  
  // Использование методов
  myAnimal.sayHello(); // Вывод: Привет, меня зовут Alex
  myCat.sayHello();    // Вывод: Привет, меня зовут Мурзик
  myCat.meow();        // Вывод: Мяу, мяу!
  

  //В этом примере у нас есть родительский класс Animal, который имеет метод sayHello. 
  //Дочерний класс Cat создается с использованием конструктора родительского класса Animal.call(this, name), чтобы унаследовать свойства. 
  //Затем мы устанавливаем прототип дочернего класса Cat.prototype равным новому объекту, созданному на основе прототипа родительского класса Object.create(Animal.prototype). 
  //Это обеспечивает наследование методов от родительского класса.

```



